{"version":3,"file":"Graph.mjs","sources":["../../../src/graphs/Graph.ts"],"sourcesContent":["/* eslint-disable no-console */\n// src/graphs/Graph.ts\nimport { nanoid } from 'nanoid';\nimport { concat } from '@langchain/core/utils/stream';\nimport { ToolNode } from '@langchain/langgraph/prebuilt';\nimport { ChatVertexAI } from '@langchain/google-vertexai';\nimport {\n  START,\n  END,\n  Command,\n  StateGraph,\n  Annotation,\n  messagesStateReducer,\n} from '@langchain/langgraph';\nimport {\n  Runnable,\n  RunnableConfig,\n  RunnableLambda,\n} from '@langchain/core/runnables';\nimport {\n  ToolMessage,\n  SystemMessage,\n  AIMessageChunk,\n} from '@langchain/core/messages';\nimport type {\n  BaseMessageFields,\n  UsageMetadata,\n  BaseMessage,\n} from '@langchain/core/messages';\nimport type { ToolCall } from '@langchain/core/messages/tool';\nimport type * as t from '@/types';\nimport {\n  GraphNodeKeys,\n  ContentTypes,\n  GraphEvents,\n  Providers,\n  StepTypes,\n  Constants,\n} from '@/common';\nimport {\n  formatAnthropicArtifactContent,\n  ensureThinkingBlockInMessages,\n  convertMessagesToContent,\n  addBedrockCacheControl,\n  modifyDeltaProperties,\n  formatArtifactPayload,\n  formatContentStrings,\n  createPruneMessages,\n  addCacheControl,\n  extractToolDiscoveries,\n} from '@/messages';\nimport {\n  resetIfNotEmpty,\n  isOpenAILike,\n  isGoogleLike,\n  joinKeys,\n  sleep,\n} from '@/utils';\nimport { getChatModelClass, manualToolStreamProviders } from '@/llm/providers';\nimport { ToolNode as CustomToolNode, toolsCondition } from '@/tools/ToolNode';\nimport { ChatOpenAI, AzureChatOpenAI } from '@/llm/openai';\nimport { safeDispatchCustomEvent } from '@/utils/events';\nimport { AgentContext } from '@/agents/AgentContext';\nimport { createFakeStreamingLLM } from '@/llm/fake';\nimport { HandlerRegistry } from '@/events';\n\nconst { AGENT, TOOLS } = GraphNodeKeys;\n\n/**\n * Model context windows for compaction threshold calculation\n */\nconst MODEL_CONTEXT_WINDOWS: Record<string, number> = {\n  'gpt-5.2': 128000,\n  'gpt-5.2-pro': 128000,\n  'gpt-5.2-codex': 128000,\n};\n\n/**\n * Get the context window size for a model\n */\nfunction getModelContextWindow(model: string): number {\n  const lowerModel = model.toLowerCase();\n  for (const [key, value] of Object.entries(MODEL_CONTEXT_WINDOWS)) {\n    if (lowerModel.includes(key)) {\n      return value;\n    }\n  }\n  return 128000;\n}\n\n/**\n * Check if a model supports compaction\n */\nfunction supportsCompaction(model: string): boolean {\n  if (!model) return false;\n  const lowerModel = model.toLowerCase();\n  return lowerModel.includes('gpt-5.2');\n}\n\n/**\n * Estimate tokens for a message (rough estimation: 4 chars per token)\n */\nfunction estimateMessageTokens(message: BaseMessage): number {\n  const content = message.content;\n  if (typeof content === 'string') {\n    return Math.ceil(content.length / 4);\n  }\n  if (Array.isArray(content)) {\n    return Math.ceil(JSON.stringify(content).length / 4);\n  }\n  return 0;\n}\n\n/**\n * Truncate messages to fit within context window when compaction isn't enough.\n * Keeps system message and most recent messages, removes old middle messages.\n */\nfunction truncateToFitContext(\n  messages: BaseMessage[],\n  maxTokens: number,\n  reserveTokens: number = 8000\n): BaseMessage[] {\n  const targetTokens = maxTokens - reserveTokens; // Leave room for response\n\n  let totalTokens = messages.reduce((sum, m) => sum + estimateMessageTokens(m), 0);\n\n  if (totalTokens <= targetTokens) {\n    return messages;\n  }\n\n  console.log(`[Truncation] Messages exceed ${targetTokens} tokens (${totalTokens}), truncating...`);\n\n  // Keep system message (first) and recent messages, remove from middle\n  const result: BaseMessage[] = [];\n  let currentTokens = 0;\n\n  // Always keep system message if present\n  const firstMsg = messages[0];\n  if (firstMsg && firstMsg._getType() === 'system') {\n    result.push(firstMsg);\n    currentTokens += estimateMessageTokens(firstMsg);\n  }\n\n  // Add messages from the end until we hit the limit\n  const remainingMessages = firstMsg?._getType() === 'system' ? messages.slice(1) : messages;\n  const messagesToAdd: BaseMessage[] = [];\n\n  for (let i = remainingMessages.length - 1; i >= 0; i--) {\n    const msg = remainingMessages[i];\n    const msgTokens = estimateMessageTokens(msg);\n\n    if (currentTokens + msgTokens <= targetTokens) {\n      messagesToAdd.unshift(msg);\n      currentTokens += msgTokens;\n    } else {\n      // Skip this message and older ones\n      break;\n    }\n  }\n\n  result.push(...messagesToAdd);\n\n  console.log(`[Truncation] Reduced from ${totalTokens} to ${currentTokens} tokens (${result.length} messages)`);\n\n  return result;\n}\n\n/**\n * Convert BaseMessage to OpenAI Responses API format\n * Note: Tool messages are converted to user messages since /responses/compact\n * only supports 'assistant', 'system', 'developer', and 'user' roles\n */\nfunction convertToResponsesFormat(\n  messages: BaseMessage[]\n): Array<{ role: string; content: string }> {\n  const result: Array<{ role: string; content: string }> = [];\n\n  for (const msg of messages) {\n    const msgType = msg._getType();\n    let role: string;\n    let content: string;\n\n    // Convert content to string\n    if (typeof msg.content === 'string') {\n      content = msg.content;\n    } else if (Array.isArray(msg.content)) {\n      // Handle content arrays by extracting text\n      content = msg.content\n        .map((c) => {\n          if (typeof c === 'string') return c;\n          if (typeof c === 'object' && c !== null && 'text' in c) {\n            return (c as { text: string }).text;\n          }\n          return JSON.stringify(c);\n        })\n        .join('\\n');\n    } else {\n      content = JSON.stringify(msg.content);\n    }\n\n    // Skip empty content\n    if (!content || content.trim() === '') {\n      continue;\n    }\n\n    if (msgType === 'human') {\n      role = 'user';\n    } else if (msgType === 'ai') {\n      role = 'assistant';\n      // For AI messages with tool calls but no text content, add a placeholder\n      if (!content.trim() && 'tool_calls' in msg && msg.tool_calls) {\n        content = '[Tool calls made]';\n      }\n    } else if (msgType === 'system') {\n      role = 'system';\n    } else if (msgType === 'tool') {\n      // Convert tool messages to user messages with context\n      role = 'user';\n      const toolName = 'name' in msg ? (msg as { name: string }).name : 'tool';\n      content = `[Tool result from ${toolName}]: ${content}`;\n    } else {\n      role = 'user';\n    }\n\n    result.push({ role, content });\n  }\n\n  return result;\n}\n\ninterface CompactionResult {\n  compacted: boolean;\n  messages?: BaseMessage[];\n  originalTokens?: number;\n  compactedTokens?: number;\n}\n\n/**\n * Call the OpenAI /responses/compact endpoint to compact conversation\n */\nasync function compactConversation(\n  messages: BaseMessage[],\n  config: t.CompactionConfig,\n  model: string,\n  instructions?: string\n): Promise<CompactionResult> {\n  const thresholdPercent = config.thresholdPercent ?? 0.7;\n  const minTokens = config.minTokensBeforeCompaction ?? 10000;\n  const contextWindow = getModelContextWindow(model);\n  const threshold = contextWindow * thresholdPercent;\n\n  // Estimate current tokens\n  let totalTokens = 0;\n  for (const msg of messages) {\n    totalTokens += estimateMessageTokens(msg);\n  }\n  if (instructions) {\n    totalTokens += Math.ceil(instructions.length / 4);\n  }\n\n  console.log(\n    `[Compaction] Token estimate: ${totalTokens}, threshold: ${threshold}, minTokens: ${minTokens}`\n  );\n\n  // Check if compaction should trigger\n  if (totalTokens < minTokens || totalTokens < threshold) {\n    return { compacted: false, originalTokens: totalTokens };\n  }\n\n  console.log(`[Compaction] Triggering compaction for ${totalTokens} tokens`);\n\n  try {\n    const input = convertToResponsesFormat(messages);\n    const baseURL = config.baseURL || 'https://api.openai.com/v1';\n\n    const response = await fetch(`${baseURL}/responses/compact`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${config.apiKey}`,\n      },\n      body: JSON.stringify({\n        model,\n        input,\n        ...(instructions && config.preserveInstructions !== false\n          ? { instructions }\n          : {}),\n      }),\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error(`[Compaction] API error: ${response.status} - ${errorText}`);\n      return { compacted: false, originalTokens: totalTokens };\n    }\n\n    // The compaction API returns items that may include:\n    // - {type: \"message\", role: \"user\", content: \"...\"} - user messages kept verbatim\n    // - {type: \"compaction\", encrypted_content: \"...\"} - encrypted compaction item\n    const data = (await response.json()) as {\n      output?: Array<Record<string, unknown>>;\n      usage?: { total_tokens?: number; input_tokens?: number; output_tokens?: number };\n    };\n\n    if (!data.output || data.output.length === 0) {\n      console.warn('[Compaction] No output from compaction API');\n      return { compacted: false, originalTokens: totalTokens };\n    }\n\n    console.log(`[Compaction] API returned ${data.output.length} items`);\n\n    // Log the types of items returned\n    const itemTypes = data.output.map((item) => item.type || item.role || 'unknown');\n    console.log(`[Compaction] Item types: ${itemTypes.join(', ')}`);\n\n    // Create a single AIMessage that carries all the compacted items in response_metadata.output\n    // This allows _convertMessagesToOpenAIResponsesParams to pass them through directly\n    const { AIMessage } = await import('@langchain/core/messages');\n    const compactedMessage = new AIMessage({\n      content: '[Compacted conversation context]',\n      response_metadata: {\n        output: data.output, // Raw items from compaction API - will be passed through directly\n      },\n    });\n\n    const compactedTokens = data.usage?.output_tokens || data.usage?.total_tokens || 1000;\n\n    console.log(\n      `[Compaction] Compacted: ${totalTokens} -> ${compactedTokens} tokens (${data.output.length} items preserved in response_metadata)`\n    );\n\n    return {\n      compacted: true,\n      messages: [compactedMessage], // Single message carrying all compacted items\n      originalTokens: totalTokens,\n      compactedTokens,\n    };\n  } catch (error) {\n    console.error('[Compaction] Error during compaction:', error);\n    return { compacted: false, originalTokens: totalTokens };\n  }\n}\n\nexport abstract class Graph<\n  T extends t.BaseGraphState = t.BaseGraphState,\n  _TNodeName extends string = string,\n> {\n  abstract resetValues(): void;\n  abstract initializeTools({\n    currentTools,\n    currentToolMap,\n  }: {\n    currentTools?: t.GraphTools;\n    currentToolMap?: t.ToolMap;\n  }): CustomToolNode<T> | ToolNode<T>;\n  abstract initializeModel({\n    currentModel,\n    tools,\n    clientOptions,\n  }: {\n    currentModel?: t.ChatModel;\n    tools?: t.GraphTools;\n    clientOptions?: t.ClientOptions;\n  }): Runnable;\n  abstract getRunMessages(): BaseMessage[] | undefined;\n  abstract getContentParts(): t.MessageContentComplex[] | undefined;\n  abstract generateStepId(stepKey: string): [string, number];\n  abstract getKeyList(\n    metadata: Record<string, unknown> | undefined\n  ): (string | number | undefined)[];\n  abstract getStepKey(metadata: Record<string, unknown> | undefined): string;\n  abstract checkKeyList(keyList: (string | number | undefined)[]): boolean;\n  abstract getStepIdByKey(stepKey: string, index?: number): string;\n  abstract getRunStep(stepId: string): t.RunStep | undefined;\n  abstract dispatchRunStep(\n    stepKey: string,\n    stepDetails: t.StepDetails,\n    metadata?: Record<string, unknown>\n  ): Promise<string>;\n  abstract dispatchRunStepDelta(\n    id: string,\n    delta: t.ToolCallDelta\n  ): Promise<void>;\n  abstract dispatchMessageDelta(\n    id: string,\n    delta: t.MessageDelta\n  ): Promise<void>;\n  abstract dispatchReasoningDelta(\n    stepId: string,\n    delta: t.ReasoningDelta\n  ): Promise<void>;\n  abstract handleToolCallCompleted(\n    data: t.ToolEndData,\n    metadata?: Record<string, unknown>,\n    omitOutput?: boolean\n  ): Promise<void>;\n\n  abstract createCallModel(\n    agentId?: string,\n    currentModel?: t.ChatModel\n  ): (state: T, config?: RunnableConfig) => Promise<Partial<T>>;\n  messageStepHasToolCalls: Map<string, boolean> = new Map();\n  messageIdsByStepKey: Map<string, string> = new Map();\n  prelimMessageIdsByStepKey: Map<string, string> = new Map();\n  config: RunnableConfig | undefined;\n  contentData: t.RunStep[] = [];\n  stepKeyIds: Map<string, string[]> = new Map<string, string[]>();\n  contentIndexMap: Map<string, number> = new Map();\n  toolCallStepIds: Map<string, string> = new Map();\n  signal?: AbortSignal;\n  /** Set of invoked tool call IDs from non-message run steps completed mid-run, if any */\n  invokedToolIds?: Set<string>;\n  handlerRegistry: HandlerRegistry | undefined;\n  /**\n   * Tool session contexts for automatic state persistence across tool invocations.\n   * Keyed by tool name (e.g., Constants.EXECUTE_CODE).\n   * Currently supports code execution session tracking (session_id, files).\n   */\n  sessions: t.ToolSessionMap = new Map();\n}\n\nexport class StandardGraph extends Graph<t.BaseGraphState, t.GraphNode> {\n  overrideModel?: t.ChatModel;\n  /** Optional compile options passed into workflow.compile() */\n  compileOptions?: t.CompileOptions | undefined;\n  messages: BaseMessage[] = [];\n  runId: string | undefined;\n  startIndex: number = 0;\n  signal?: AbortSignal;\n  /** Map of agent contexts by agent ID */\n  agentContexts: Map<string, AgentContext> = new Map();\n  /** Default agent ID to use */\n  defaultAgentId: string;\n\n  constructor({\n    // parent-level graph inputs\n    runId,\n    signal,\n    agents,\n    tokenCounter,\n    indexTokenCountMap,\n  }: t.StandardGraphInput) {\n    super();\n    this.runId = runId;\n    this.signal = signal;\n\n    if (agents.length === 0) {\n      throw new Error('At least one agent configuration is required');\n    }\n\n    for (const agentConfig of agents) {\n      const agentContext = AgentContext.fromConfig(\n        agentConfig,\n        tokenCounter,\n        indexTokenCountMap\n      );\n\n      this.agentContexts.set(agentConfig.agentId, agentContext);\n    }\n\n    this.defaultAgentId = agents[0].agentId;\n  }\n\n  /* Init */\n\n  resetValues(keepContent?: boolean): void {\n    this.messages = [];\n    this.config = resetIfNotEmpty(this.config, undefined);\n    if (keepContent !== true) {\n      this.contentData = resetIfNotEmpty(this.contentData, []);\n      this.contentIndexMap = resetIfNotEmpty(this.contentIndexMap, new Map());\n    }\n    this.stepKeyIds = resetIfNotEmpty(this.stepKeyIds, new Map());\n    this.toolCallStepIds = resetIfNotEmpty(this.toolCallStepIds, new Map());\n    this.messageIdsByStepKey = resetIfNotEmpty(\n      this.messageIdsByStepKey,\n      new Map()\n    );\n    this.messageStepHasToolCalls = resetIfNotEmpty(\n      this.messageStepHasToolCalls,\n      new Map()\n    );\n    this.prelimMessageIdsByStepKey = resetIfNotEmpty(\n      this.prelimMessageIdsByStepKey,\n      new Map()\n    );\n    this.invokedToolIds = resetIfNotEmpty(this.invokedToolIds, undefined);\n    for (const context of this.agentContexts.values()) {\n      context.reset();\n    }\n  }\n\n  /* Run Step Processing */\n\n  getRunStep(stepId: string): t.RunStep | undefined {\n    const index = this.contentIndexMap.get(stepId);\n    if (index !== undefined) {\n      return this.contentData[index];\n    }\n    return undefined;\n  }\n\n  getAgentContext(metadata: Record<string, unknown> | undefined): AgentContext {\n    if (!metadata) {\n      throw new Error('No metadata provided to retrieve agent context');\n    }\n\n    const currentNode = metadata.langgraph_node as string;\n    if (!currentNode) {\n      throw new Error(\n        'No langgraph_node in metadata to retrieve agent context'\n      );\n    }\n\n    let agentId: string | undefined;\n    if (currentNode.startsWith(AGENT)) {\n      agentId = currentNode.substring(AGENT.length);\n    } else if (currentNode.startsWith(TOOLS)) {\n      agentId = currentNode.substring(TOOLS.length);\n    }\n\n    const agentContext = this.agentContexts.get(agentId ?? '');\n    if (!agentContext) {\n      throw new Error(`No agent context found for agent ID ${agentId}`);\n    }\n\n    return agentContext;\n  }\n\n  getStepKey(metadata: Record<string, unknown> | undefined): string {\n    if (!metadata) return '';\n\n    const keyList = this.getKeyList(metadata);\n    if (this.checkKeyList(keyList)) {\n      throw new Error('Missing metadata');\n    }\n\n    return joinKeys(keyList);\n  }\n\n  getStepIdByKey(stepKey: string, index?: number): string {\n    const stepIds = this.stepKeyIds.get(stepKey);\n    if (!stepIds) {\n      throw new Error(`No step IDs found for stepKey ${stepKey}`);\n    }\n\n    if (index === undefined) {\n      return stepIds[stepIds.length - 1];\n    }\n\n    return stepIds[index];\n  }\n\n  generateStepId(stepKey: string): [string, number] {\n    const stepIds = this.stepKeyIds.get(stepKey);\n    let newStepId: string | undefined;\n    let stepIndex = 0;\n    if (stepIds) {\n      stepIndex = stepIds.length;\n      newStepId = `step_${nanoid()}`;\n      stepIds.push(newStepId);\n      this.stepKeyIds.set(stepKey, stepIds);\n    } else {\n      newStepId = `step_${nanoid()}`;\n      this.stepKeyIds.set(stepKey, [newStepId]);\n    }\n\n    return [newStepId, stepIndex];\n  }\n\n  getKeyList(\n    metadata: Record<string, unknown> | undefined\n  ): (string | number | undefined)[] {\n    if (!metadata) return [];\n\n    const keyList = [\n      metadata.run_id as string,\n      metadata.thread_id as string,\n      metadata.langgraph_node as string,\n      metadata.langgraph_step as number,\n      metadata.checkpoint_ns as string,\n    ];\n\n    const agentContext = this.getAgentContext(metadata);\n    if (\n      agentContext.currentTokenType === ContentTypes.THINK ||\n      agentContext.currentTokenType === 'think_and_text'\n    ) {\n      keyList.push('reasoning');\n    } else if (agentContext.tokenTypeSwitch === 'content') {\n      keyList.push('post-reasoning');\n    }\n\n    if (this.invokedToolIds != null && this.invokedToolIds.size > 0) {\n      keyList.push(this.invokedToolIds.size + '');\n    }\n\n    return keyList;\n  }\n\n  checkKeyList(keyList: (string | number | undefined)[]): boolean {\n    return keyList.some((key) => key === undefined);\n  }\n\n  /* Misc.*/\n\n  getRunMessages(): BaseMessage[] | undefined {\n    return this.messages.slice(this.startIndex);\n  }\n\n  getContentParts(): t.MessageContentComplex[] | undefined {\n    return convertMessagesToContent(this.messages.slice(this.startIndex));\n  }\n\n  /**\n   * Get all run steps, optionally filtered by agent ID\n   */\n  getRunSteps(agentId?: string): t.RunStep[] {\n    if (agentId == null || agentId === '') {\n      return [...this.contentData];\n    }\n    return this.contentData.filter((step) => step.agentId === agentId);\n  }\n\n  /**\n   * Get run steps grouped by agent ID\n   */\n  getRunStepsByAgent(): Map<string, t.RunStep[]> {\n    const stepsByAgent = new Map<string, t.RunStep[]>();\n\n    for (const step of this.contentData) {\n      if (step.agentId == null || step.agentId === '') continue;\n\n      const steps = stepsByAgent.get(step.agentId) ?? [];\n      steps.push(step);\n      stepsByAgent.set(step.agentId, steps);\n    }\n\n    return stepsByAgent;\n  }\n\n  /**\n   * Get agent IDs that participated in this run\n   */\n  getActiveAgentIds(): string[] {\n    const agentIds = new Set<string>();\n    for (const step of this.contentData) {\n      if (step.agentId != null && step.agentId !== '') {\n        agentIds.add(step.agentId);\n      }\n    }\n    return Array.from(agentIds);\n  }\n\n  /**\n   * Maps contentPart indices to agent IDs for post-run analysis\n   * Returns a map where key is the contentPart index and value is the agentId\n   */\n  getContentPartAgentMap(): Map<number, string> {\n    const contentPartAgentMap = new Map<number, string>();\n\n    for (const step of this.contentData) {\n      if (\n        step.agentId != null &&\n        step.agentId !== '' &&\n        Number.isFinite(step.index)\n      ) {\n        contentPartAgentMap.set(step.index, step.agentId);\n      }\n    }\n\n    return contentPartAgentMap;\n  }\n\n  /* Graph */\n\n  createSystemRunnable({\n    provider,\n    clientOptions,\n    instructions,\n    additional_instructions,\n  }: {\n    provider?: Providers;\n    clientOptions?: t.ClientOptions;\n    instructions?: string;\n    additional_instructions?: string;\n  }): t.SystemRunnable | undefined {\n    let finalInstructions: string | BaseMessageFields | undefined =\n      instructions;\n    if (additional_instructions != null && additional_instructions !== '') {\n      finalInstructions =\n        finalInstructions != null && finalInstructions\n          ? `${finalInstructions}\\n\\n${additional_instructions}`\n          : additional_instructions;\n    }\n\n    if (\n      finalInstructions != null &&\n      finalInstructions &&\n      provider === Providers.ANTHROPIC &&\n      (clientOptions as t.AnthropicClientOptions).promptCache === true\n    ) {\n      finalInstructions = {\n        content: [\n          {\n            type: 'text',\n            text: instructions,\n            cache_control: { type: 'ephemeral' },\n          },\n        ],\n      };\n    }\n\n    if (finalInstructions != null && finalInstructions !== '') {\n      const systemMessage = new SystemMessage(finalInstructions);\n      return RunnableLambda.from((messages: BaseMessage[]) => {\n        return [systemMessage, ...messages];\n      }).withConfig({ runName: 'prompt' });\n    }\n  }\n\n  initializeTools({\n    currentTools,\n    currentToolMap,\n    agentContext,\n  }: {\n    currentTools?: t.GraphTools;\n    currentToolMap?: t.ToolMap;\n    agentContext?: AgentContext;\n  }): CustomToolNode<t.BaseGraphState> | ToolNode<t.BaseGraphState> {\n    return new CustomToolNode<t.BaseGraphState>({\n      tools: (currentTools as t.GenericTool[] | undefined) ?? [],\n      toolMap: currentToolMap,\n      toolCallStepIds: this.toolCallStepIds,\n      errorHandler: (data, metadata) =>\n        StandardGraph.handleToolCallErrorStatic(this, data, metadata),\n      toolRegistry: agentContext?.toolRegistry,\n      sessions: this.sessions,\n    });\n  }\n\n  initializeModel({\n    provider,\n    tools,\n    clientOptions,\n  }: {\n    provider: Providers;\n    tools?: t.GraphTools;\n    clientOptions?: t.ClientOptions;\n  }): Runnable {\n    const ChatModelClass = getChatModelClass(provider);\n    const model = new ChatModelClass(clientOptions ?? {});\n\n    if (\n      isOpenAILike(provider) &&\n      (model instanceof ChatOpenAI || model instanceof AzureChatOpenAI)\n    ) {\n      model.temperature = (clientOptions as t.OpenAIClientOptions)\n        .temperature as number;\n      model.topP = (clientOptions as t.OpenAIClientOptions).topP as number;\n      model.frequencyPenalty = (clientOptions as t.OpenAIClientOptions)\n        .frequencyPenalty as number;\n      model.presencePenalty = (clientOptions as t.OpenAIClientOptions)\n        .presencePenalty as number;\n      model.n = (clientOptions as t.OpenAIClientOptions).n as number;\n    } else if (\n      provider === Providers.VERTEXAI &&\n      model instanceof ChatVertexAI\n    ) {\n      model.temperature = (clientOptions as t.VertexAIClientOptions)\n        .temperature as number;\n      model.topP = (clientOptions as t.VertexAIClientOptions).topP as number;\n      model.topK = (clientOptions as t.VertexAIClientOptions).topK as number;\n      model.topLogprobs = (clientOptions as t.VertexAIClientOptions)\n        .topLogprobs as number;\n      model.frequencyPenalty = (clientOptions as t.VertexAIClientOptions)\n        .frequencyPenalty as number;\n      model.presencePenalty = (clientOptions as t.VertexAIClientOptions)\n        .presencePenalty as number;\n      model.maxOutputTokens = (clientOptions as t.VertexAIClientOptions)\n        .maxOutputTokens as number;\n    }\n\n    if (!tools || tools.length === 0) {\n      return model as unknown as Runnable;\n    }\n\n    return (model as t.ModelWithTools).bindTools(tools);\n  }\n\n  overrideTestModel(\n    responses: string[],\n    sleep?: number,\n    toolCalls?: ToolCall[]\n  ): void {\n    this.overrideModel = createFakeStreamingLLM({\n      responses,\n      sleep,\n      toolCalls,\n    });\n  }\n\n  getNewModel({\n    provider,\n    clientOptions,\n  }: {\n    provider: Providers;\n    clientOptions?: t.ClientOptions;\n  }): t.ChatModelInstance {\n    const ChatModelClass = getChatModelClass(provider);\n    return new ChatModelClass(clientOptions ?? {});\n  }\n\n  getUsageMetadata(\n    finalMessage?: BaseMessage\n  ): Partial<UsageMetadata> | undefined {\n    if (\n      finalMessage &&\n      'usage_metadata' in finalMessage &&\n      finalMessage.usage_metadata != null\n    ) {\n      return finalMessage.usage_metadata as Partial<UsageMetadata>;\n    }\n  }\n\n  /** Execute model invocation with streaming support */\n  private async attemptInvoke(\n    {\n      currentModel,\n      finalMessages,\n      provider,\n      tools,\n    }: {\n      currentModel?: t.ChatModel;\n      finalMessages: BaseMessage[];\n      provider: Providers;\n      tools?: t.GraphTools;\n    },\n    config?: RunnableConfig\n  ): Promise<Partial<t.BaseGraphState>> {\n    const model = this.overrideModel ?? currentModel;\n    if (!model) {\n      throw new Error('No model found');\n    }\n\n    if ((tools?.length ?? 0) > 0 && manualToolStreamProviders.has(provider)) {\n      if (!model.stream) {\n        throw new Error('Model does not support stream');\n      }\n      const stream = await model.stream(finalMessages, config);\n      let finalChunk: AIMessageChunk | undefined;\n      for await (const chunk of stream) {\n        await safeDispatchCustomEvent(\n          GraphEvents.CHAT_MODEL_STREAM,\n          { chunk, emitted: true },\n          config\n        );\n        finalChunk = finalChunk ? concat(finalChunk, chunk) : chunk;\n      }\n      finalChunk = modifyDeltaProperties(provider, finalChunk);\n      return { messages: [finalChunk as AIMessageChunk] };\n    } else {\n      const finalMessage = await model.invoke(finalMessages, config);\n      if ((finalMessage.tool_calls?.length ?? 0) > 0) {\n        finalMessage.tool_calls = finalMessage.tool_calls?.filter(\n          (tool_call: ToolCall) => !!tool_call.name\n        );\n      }\n      return { messages: [finalMessage] };\n    }\n  }\n\n  cleanupSignalListener(currentModel?: t.ChatModel): void {\n    if (!this.signal) {\n      return;\n    }\n    const model = this.overrideModel ?? currentModel;\n    if (!model) {\n      return;\n    }\n    const client = (model as ChatOpenAI | undefined)?.exposedClient;\n    if (!client?.abortHandler) {\n      return;\n    }\n    this.signal.removeEventListener('abort', client.abortHandler);\n    client.abortHandler = undefined;\n  }\n\n  createCallModel(agentId = 'default') {\n    return async (\n      state: t.BaseGraphState,\n      config?: RunnableConfig\n    ): Promise<Partial<t.BaseGraphState>> => {\n      /**\n       * Get agent context - it must exist by this point\n       */\n      const agentContext = this.agentContexts.get(agentId);\n      if (!agentContext) {\n        throw new Error(`Agent context not found for agentId: ${agentId}`);\n      }\n\n      if (!config) {\n        throw new Error('No config provided');\n      }\n\n      const { messages } = state;\n\n      // Extract tool discoveries from current turn only (similar to formatArtifactPayload pattern)\n      const discoveredNames = extractToolDiscoveries(messages);\n      if (discoveredNames.length > 0) {\n        agentContext.markToolsAsDiscovered(discoveredNames);\n      }\n\n      const toolsForBinding = agentContext.getToolsForBinding();\n      let model =\n        this.overrideModel ??\n        this.initializeModel({\n          tools: toolsForBinding,\n          provider: agentContext.provider,\n          clientOptions: agentContext.clientOptions,\n        });\n\n      if (agentContext.systemRunnable) {\n        model = agentContext.systemRunnable.pipe(model as Runnable);\n      }\n\n      if (agentContext.tokenCalculationPromise) {\n        await agentContext.tokenCalculationPromise;\n      }\n      if (!config.signal) {\n        config.signal = this.signal;\n      }\n      this.config = config;\n\n      let messagesToUse = messages;\n      if (\n        !agentContext.pruneMessages &&\n        agentContext.tokenCounter &&\n        agentContext.maxContextTokens != null &&\n        agentContext.indexTokenCountMap[0] != null\n      ) {\n        const isAnthropicWithThinking =\n          (agentContext.provider === Providers.ANTHROPIC &&\n            (agentContext.clientOptions as t.AnthropicClientOptions).thinking !=\n              null) ||\n          (agentContext.provider === Providers.BEDROCK &&\n            (agentContext.clientOptions as t.BedrockAnthropicInput)\n              .additionalModelRequestFields?.['thinking'] != null) ||\n          (agentContext.provider === Providers.OPENAI &&\n            (\n              (agentContext.clientOptions as t.OpenAIClientOptions).modelKwargs\n                ?.thinking as t.AnthropicClientOptions['thinking']\n            )?.type === 'enabled');\n\n        agentContext.pruneMessages = createPruneMessages({\n          startIndex: this.startIndex,\n          provider: agentContext.provider,\n          tokenCounter: agentContext.tokenCounter,\n          maxTokens: agentContext.maxContextTokens,\n          thinkingEnabled: isAnthropicWithThinking,\n          indexTokenCountMap: agentContext.indexTokenCountMap,\n        });\n      }\n      if (agentContext.pruneMessages) {\n        const { context, indexTokenCountMap } = agentContext.pruneMessages({\n          messages,\n          usageMetadata: agentContext.currentUsage,\n          // startOnMessageType: 'human',\n        });\n        agentContext.indexTokenCountMap = indexTokenCountMap;\n        messagesToUse = context;\n      }\n\n      /**\n       * Context compaction check - runs between agent loop iterations.\n       * When token count approaches context limit, compress conversation\n       * using OpenAI's /responses/compact endpoint.\n       */\n      const modelName =\n        (agentContext.clientOptions as t.OpenAIClientOptions)?.model || '';\n      const compactionEnabled = agentContext.compaction?.enabled;\n      const hasApiKey = !!agentContext.compaction?.apiKey;\n      const modelSupported = supportsCompaction(modelName);\n\n      console.log(\n        `[Compaction] Check - enabled: ${compactionEnabled}, apiKey: ${hasApiKey}, model: ${modelName}, supported: ${modelSupported}`\n      );\n\n      if (compactionEnabled && hasApiKey && modelSupported && agentContext.compaction) {\n        const compactionResult = await compactConversation(\n          messagesToUse,\n          agentContext.compaction,\n          modelName,\n          agentContext.instructions\n        );\n\n        if (compactionResult.compacted && compactionResult.messages) {\n          console.log(\n            `[Compaction] Using compacted messages: ${compactionResult.originalTokens} -> ${compactionResult.compactedTokens} tokens`\n          );\n          messagesToUse = compactionResult.messages;\n          // Reset token count map since messages have been compacted\n          agentContext.indexTokenCountMap = {};\n        }\n\n        // If still over context limit after compaction, truncate as fallback\n        const contextWindow = getModelContextWindow(modelName);\n        const currentTokens = messagesToUse.reduce((sum, m) => sum + estimateMessageTokens(m), 0);\n\n        if (currentTokens > contextWindow * 0.9) {\n          console.log(`[Compaction] Still over limit after compaction (${currentTokens} > ${contextWindow * 0.9}), applying truncation...`);\n          messagesToUse = truncateToFitContext(messagesToUse, contextWindow);\n          agentContext.indexTokenCountMap = {};\n        }\n      }\n\n      let finalMessages = messagesToUse;\n      if (agentContext.useLegacyContent) {\n        finalMessages = formatContentStrings(finalMessages);\n      }\n\n      const lastMessageX =\n        finalMessages.length >= 2\n          ? finalMessages[finalMessages.length - 2]\n          : null;\n      const lastMessageY =\n        finalMessages.length >= 1\n          ? finalMessages[finalMessages.length - 1]\n          : null;\n\n      if (\n        agentContext.provider === Providers.BEDROCK &&\n        lastMessageX instanceof AIMessageChunk &&\n        lastMessageY instanceof ToolMessage &&\n        typeof lastMessageX.content === 'string'\n      ) {\n        finalMessages[finalMessages.length - 2].content = '';\n      }\n\n      const isLatestToolMessage = lastMessageY instanceof ToolMessage;\n\n      if (\n        isLatestToolMessage &&\n        agentContext.provider === Providers.ANTHROPIC\n      ) {\n        formatAnthropicArtifactContent(finalMessages);\n      } else if (\n        isLatestToolMessage &&\n        ((isOpenAILike(agentContext.provider) &&\n          agentContext.provider !== Providers.DEEPSEEK) ||\n          isGoogleLike(agentContext.provider))\n      ) {\n        formatArtifactPayload(finalMessages);\n      }\n\n      if (agentContext.provider === Providers.ANTHROPIC) {\n        const anthropicOptions = agentContext.clientOptions as\n          | t.AnthropicClientOptions\n          | undefined;\n        if (anthropicOptions?.promptCache === true) {\n          finalMessages = addCacheControl<BaseMessage>(finalMessages);\n        }\n      } else if (agentContext.provider === Providers.BEDROCK) {\n        const bedrockOptions = agentContext.clientOptions as\n          | t.BedrockAnthropicClientOptions\n          | undefined;\n        if (bedrockOptions?.promptCache === true) {\n          finalMessages = addBedrockCacheControl<BaseMessage>(finalMessages);\n        }\n      }\n\n      /**\n       * Handle edge case: when switching from a non-thinking agent to a thinking-enabled agent,\n       * convert AI messages with tool calls to HumanMessages to avoid thinking block requirements.\n       * This is required by Anthropic/Bedrock when thinking is enabled.\n       */\n      const isAnthropicWithThinking =\n        (agentContext.provider === Providers.ANTHROPIC &&\n          (agentContext.clientOptions as t.AnthropicClientOptions).thinking !=\n            null) ||\n        (agentContext.provider === Providers.BEDROCK &&\n          (agentContext.clientOptions as t.BedrockAnthropicInput)\n            .additionalModelRequestFields?.['thinking'] != null);\n\n      if (isAnthropicWithThinking) {\n        finalMessages = ensureThinkingBlockInMessages(\n          finalMessages,\n          agentContext.provider\n        );\n      }\n\n      if (\n        agentContext.lastStreamCall != null &&\n        agentContext.streamBuffer != null\n      ) {\n        const timeSinceLastCall = Date.now() - agentContext.lastStreamCall;\n        if (timeSinceLastCall < agentContext.streamBuffer) {\n          const timeToWait =\n            Math.ceil((agentContext.streamBuffer - timeSinceLastCall) / 1000) *\n            1000;\n          await sleep(timeToWait);\n        }\n      }\n\n      agentContext.lastStreamCall = Date.now();\n\n      let result: Partial<t.BaseGraphState> | undefined;\n      const fallbacks =\n        (agentContext.clientOptions as t.LLMConfig | undefined)?.fallbacks ??\n        [];\n\n      if (finalMessages.length === 0) {\n        throw new Error(\n          JSON.stringify({\n            type: 'empty_messages',\n            info: 'Message pruning removed all messages as none fit in the context window. Please increase the context window size or make your message shorter.',\n          })\n        );\n      }\n\n      try {\n        result = await this.attemptInvoke(\n          {\n            currentModel: model,\n            finalMessages,\n            provider: agentContext.provider,\n            tools: agentContext.tools,\n          },\n          config\n        );\n      } catch (primaryError) {\n        let lastError: unknown = primaryError;\n        for (const fb of fallbacks) {\n          try {\n            let model = this.getNewModel({\n              provider: fb.provider,\n              clientOptions: fb.clientOptions,\n            });\n            const bindableTools = agentContext.tools;\n            model = (\n              !bindableTools || bindableTools.length === 0\n                ? model\n                : model.bindTools(bindableTools)\n            ) as t.ChatModelInstance;\n            result = await this.attemptInvoke(\n              {\n                currentModel: model,\n                finalMessages,\n                provider: fb.provider,\n                tools: agentContext.tools,\n              },\n              config\n            );\n            lastError = undefined;\n            break;\n          } catch (e) {\n            lastError = e;\n            continue;\n          }\n        }\n        if (lastError !== undefined) {\n          throw lastError;\n        }\n      }\n\n      if (!result) {\n        throw new Error('No result after model invocation');\n      }\n      agentContext.currentUsage = this.getUsageMetadata(result.messages?.[0]);\n      this.cleanupSignalListener();\n      return result;\n    };\n  }\n\n  createAgentNode(agentId: string): t.CompiledAgentWorfklow {\n    const agentContext = this.agentContexts.get(agentId);\n    if (!agentContext) {\n      throw new Error(`Agent context not found for agentId: ${agentId}`);\n    }\n\n    const agentNode = `${AGENT}${agentId}` as const;\n    const toolNode = `${TOOLS}${agentId}` as const;\n\n    const routeMessage = (\n      state: t.BaseGraphState,\n      config?: RunnableConfig\n    ): string => {\n      this.config = config;\n      return toolsCondition(state, toolNode, this.invokedToolIds);\n    };\n\n    const StateAnnotation = Annotation.Root({\n      messages: Annotation<BaseMessage[]>({\n        reducer: messagesStateReducer,\n        default: () => [],\n      }),\n    });\n\n    const workflow = new StateGraph(StateAnnotation)\n      .addNode(agentNode, this.createCallModel(agentId))\n      .addNode(\n        toolNode,\n        this.initializeTools({\n          currentTools: agentContext.tools,\n          currentToolMap: agentContext.toolMap,\n          agentContext,\n        })\n      )\n      .addEdge(START, agentNode)\n      .addConditionalEdges(agentNode, routeMessage)\n      .addEdge(toolNode, agentContext.toolEnd ? END : agentNode);\n\n    // Cast to unknown to avoid tight coupling to external types; options are opt-in\n    return workflow.compile(this.compileOptions as unknown as never);\n  }\n\n  createWorkflow(): t.CompiledStateWorkflow {\n    /** Use the default (first) agent for now */\n    const agentNode = this.createAgentNode(this.defaultAgentId);\n    const StateAnnotation = Annotation.Root({\n      messages: Annotation<BaseMessage[]>({\n        reducer: (a, b) => {\n          if (!a.length) {\n            this.startIndex = a.length + b.length;\n          }\n          const result = messagesStateReducer(a, b);\n          this.messages = result;\n          return result;\n        },\n        default: () => [],\n      }),\n    });\n    const workflow = new StateGraph(StateAnnotation)\n      .addNode(this.defaultAgentId, agentNode, { ends: [END] })\n      .addEdge(START, this.defaultAgentId)\n      .compile();\n\n    return workflow;\n  }\n\n  /**\n   * Indicates if this is a multi-agent graph.\n   * Override in MultiAgentGraph to return true.\n   * Used to conditionally include agentId in RunStep for frontend rendering.\n   */\n  protected isMultiAgentGraph(): boolean {\n    return false;\n  }\n\n  /**\n   * Get the parallel group ID for an agent, if any.\n   * Override in MultiAgentGraph to provide actual group IDs.\n   * Group IDs are incrementing numbers (1, 2, 3...) reflecting execution order.\n   * @param _agentId - The agent ID to look up\n   * @returns undefined for StandardGraph (no parallel groups), or group number for MultiAgentGraph\n   */\n  protected getParallelGroupIdForAgent(_agentId: string): number | undefined {\n    return undefined;\n  }\n\n  /* Dispatchers */\n\n  /**\n   * Dispatches a run step to the client, returns the step ID\n   */\n  async dispatchRunStep(\n    stepKey: string,\n    stepDetails: t.StepDetails,\n    metadata?: Record<string, unknown>\n  ): Promise<string> {\n    if (!this.config) {\n      throw new Error('No config provided');\n    }\n\n    const [stepId, stepIndex] = this.generateStepId(stepKey);\n    if (stepDetails.type === StepTypes.TOOL_CALLS && stepDetails.tool_calls) {\n      for (const tool_call of stepDetails.tool_calls) {\n        const toolCallId = tool_call.id ?? '';\n        if (!toolCallId || this.toolCallStepIds.has(toolCallId)) {\n          continue;\n        }\n        this.toolCallStepIds.set(toolCallId, stepId);\n      }\n    }\n\n    const runStep: t.RunStep = {\n      stepIndex,\n      id: stepId,\n      type: stepDetails.type,\n      index: this.contentData.length,\n      stepDetails,\n      usage: null,\n    };\n\n    const runId = this.runId ?? '';\n    if (runId) {\n      runStep.runId = runId;\n    }\n\n    /**\n     * Extract agentId and parallelGroupId from metadata\n     * Only set agentId for MultiAgentGraph (so frontend knows when to show agent labels)\n     */\n    if (metadata) {\n      try {\n        const agentContext = this.getAgentContext(metadata);\n        if (this.isMultiAgentGraph() && agentContext.agentId) {\n          // Only include agentId for MultiAgentGraph - enables frontend to show agent labels\n          runStep.agentId = agentContext.agentId;\n          // Set group ID if this agent is part of a parallel group\n          // Group IDs are incrementing numbers (1, 2, 3...) reflecting execution order\n          const groupId = this.getParallelGroupIdForAgent(agentContext.agentId);\n          if (groupId != null) {\n            runStep.groupId = groupId;\n          }\n        }\n      } catch (_e) {\n        /** If we can't get agent context, that's okay - agentId remains undefined */\n      }\n    }\n\n    this.contentData.push(runStep);\n    this.contentIndexMap.set(stepId, runStep.index);\n    await safeDispatchCustomEvent(\n      GraphEvents.ON_RUN_STEP,\n      runStep,\n      this.config\n    );\n    return stepId;\n  }\n\n  async handleToolCallCompleted(\n    data: t.ToolEndData,\n    metadata?: Record<string, unknown>,\n    omitOutput?: boolean\n  ): Promise<void> {\n    if (!this.config) {\n      throw new Error('No config provided');\n    }\n\n    if (!data.output) {\n      return;\n    }\n\n    const { input, output: _output } = data;\n    if ((_output as Command | undefined)?.lg_name === 'Command') {\n      return;\n    }\n    const output = _output as ToolMessage;\n    const { tool_call_id } = output;\n    const stepId = this.toolCallStepIds.get(tool_call_id) ?? '';\n    if (!stepId) {\n      throw new Error(`No stepId found for tool_call_id ${tool_call_id}`);\n    }\n\n    const runStep = this.getRunStep(stepId);\n    if (!runStep) {\n      throw new Error(`No run step found for stepId ${stepId}`);\n    }\n\n    /**\n     * Extract and store code execution session context from artifacts.\n     * Each file is stamped with its source session_id to support multi-session file tracking.\n     * When the same filename appears in a later execution, the newer version replaces the old.\n     */\n    const toolName = output.name;\n    if (\n      toolName === Constants.EXECUTE_CODE ||\n      toolName === Constants.PROGRAMMATIC_TOOL_CALLING\n    ) {\n      const artifact = output.artifact as t.CodeExecutionArtifact | undefined;\n      const newFiles = artifact?.files ?? [];\n      const hasNewFiles = newFiles.length > 0;\n\n      if (\n        hasNewFiles &&\n        artifact?.session_id != null &&\n        artifact.session_id !== ''\n      ) {\n        /**\n         * Stamp each new file with its source session_id.\n         * This enables files from different executions (parallel or sequential)\n         * to be tracked and passed to subsequent calls.\n         */\n        const filesWithSession: t.FileRefs = newFiles.map((file) => ({\n          ...file,\n          session_id: artifact.session_id,\n        }));\n\n        const existingSession = this.sessions.get(Constants.EXECUTE_CODE) as\n          | t.CodeSessionContext\n          | undefined;\n        const existingFiles = existingSession?.files ?? [];\n\n        /**\n         * Merge files, preferring latest versions by name.\n         * If a file with the same name exists, replace it with the new version.\n         * This handles cases where files are edited/recreated in subsequent executions.\n         */\n        const newFileNames = new Set(filesWithSession.map((f) => f.name));\n        const filteredExisting = existingFiles.filter(\n          (f) => !newFileNames.has(f.name)\n        );\n\n        this.sessions.set(Constants.EXECUTE_CODE, {\n          /** Keep latest session_id for reference/fallback */\n          session_id: artifact.session_id,\n          /** Accumulated files with latest versions preferred */\n          files: [...filteredExisting, ...filesWithSession],\n          lastUpdated: Date.now(),\n        });\n      }\n    }\n\n    const dispatchedOutput =\n      typeof output.content === 'string'\n        ? output.content\n        : JSON.stringify(output.content);\n\n    const args = typeof input === 'string' ? input : input.input;\n    const tool_call = {\n      args: typeof args === 'string' ? args : JSON.stringify(args),\n      name: output.name ?? '',\n      id: output.tool_call_id,\n      output: omitOutput === true ? '' : dispatchedOutput,\n      progress: 1,\n    };\n\n    await this.handlerRegistry\n      ?.getHandler(GraphEvents.ON_RUN_STEP_COMPLETED)\n      ?.handle(\n        GraphEvents.ON_RUN_STEP_COMPLETED,\n        {\n          result: {\n            id: stepId,\n            index: runStep.index,\n            type: 'tool_call',\n            tool_call,\n          } as t.ToolCompleteEvent,\n        },\n        metadata,\n        this\n      );\n  }\n  /**\n   * Static version of handleToolCallError to avoid creating strong references\n   * that prevent garbage collection\n   */\n  static async handleToolCallErrorStatic(\n    graph: StandardGraph,\n    data: t.ToolErrorData,\n    metadata?: Record<string, unknown>\n  ): Promise<void> {\n    if (!graph.config) {\n      throw new Error('No config provided');\n    }\n\n    if (!data.id) {\n      console.warn('No Tool ID provided for Tool Error');\n      return;\n    }\n\n    const stepId = graph.toolCallStepIds.get(data.id) ?? '';\n    if (!stepId) {\n      throw new Error(`No stepId found for tool_call_id ${data.id}`);\n    }\n\n    const { name, input: args, error } = data;\n\n    const runStep = graph.getRunStep(stepId);\n    if (!runStep) {\n      throw new Error(`No run step found for stepId ${stepId}`);\n    }\n\n    const tool_call: t.ProcessedToolCall = {\n      id: data.id,\n      name: name || '',\n      args: typeof args === 'string' ? args : JSON.stringify(args),\n      output: `Error processing tool${error?.message != null ? `: ${error.message}` : ''}`,\n      progress: 1,\n    };\n\n    await graph.handlerRegistry\n      ?.getHandler(GraphEvents.ON_RUN_STEP_COMPLETED)\n      ?.handle(\n        GraphEvents.ON_RUN_STEP_COMPLETED,\n        {\n          result: {\n            id: stepId,\n            index: runStep.index,\n            type: 'tool_call',\n            tool_call,\n          } as t.ToolCompleteEvent,\n        },\n        metadata,\n        graph\n      );\n  }\n\n  /**\n   * Instance method that delegates to the static method\n   * Kept for backward compatibility\n   */\n  async handleToolCallError(\n    data: t.ToolErrorData,\n    metadata?: Record<string, unknown>\n  ): Promise<void> {\n    await StandardGraph.handleToolCallErrorStatic(this, data, metadata);\n  }\n\n  async dispatchRunStepDelta(\n    id: string,\n    delta: t.ToolCallDelta\n  ): Promise<void> {\n    if (!this.config) {\n      throw new Error('No config provided');\n    } else if (!id) {\n      throw new Error('No step ID found');\n    }\n    const runStepDelta: t.RunStepDeltaEvent = {\n      id,\n      delta,\n    };\n    await safeDispatchCustomEvent(\n      GraphEvents.ON_RUN_STEP_DELTA,\n      runStepDelta,\n      this.config\n    );\n  }\n\n  async dispatchMessageDelta(id: string, delta: t.MessageDelta): Promise<void> {\n    if (!this.config) {\n      throw new Error('No config provided');\n    }\n    const messageDelta: t.MessageDeltaEvent = {\n      id,\n      delta,\n    };\n    await safeDispatchCustomEvent(\n      GraphEvents.ON_MESSAGE_DELTA,\n      messageDelta,\n      this.config\n    );\n  }\n\n  dispatchReasoningDelta = async (\n    stepId: string,\n    delta: t.ReasoningDelta\n  ): Promise<void> => {\n    if (!this.config) {\n      throw new Error('No config provided');\n    }\n    const reasoningDelta: t.ReasoningDeltaEvent = {\n      id: stepId,\n      delta,\n    };\n    await safeDispatchCustomEvent(\n      GraphEvents.ON_REASONING_DELTA,\n      reasoningDelta,\n      this.config\n    );\n  };\n}\n"],"names":["CustomToolNode"],"mappings":"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"}